---
title: "Gemini on Models"
author: "Robert W. Walker"
date: "2026-01-14"
image: "image.png"
---

```{r setup, include=FALSE}
library(reticulate)
```


# Bond Funds Analysis: Complete Conversation Log

This document contains the complete analytical workflow generated during our session, formatted for use in Quarto.

## 1. Initial Exploration: Asset Distribution

We began by examining the distribution of assets across the funds using a histogram with density overlays.

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

# Load the dataset
df = pd.read_csv('./BondFunds.csv')
assets = df['Assets'].dropna()

# Define bin parameters
bin_size = 100
bins = np.arange(0, assets.max() + bin_size, bin_size)

# Create the plot
plt.figure(figsize=(12, 7))

# 1. Histogram
plt.hist(assets, bins=bins, density=True, color='skyblue', edgecolor='black', alpha=0.5, label='Histogram (Bins=100m)')

# Generate points for the KDE lines
x_eval = np.linspace(0, assets.max(), 1000)

# 2. Density with Default Bandwidth
kde_default = gaussian_kde(assets)
plt.plot(x_eval, kde_default(x_eval), color='blue', lw=2, label='Density (Default BW)')

# 3. Density with Bandwidth = 2
kde_bw2 = gaussian_kde(assets, bw_method=2.0)
plt.plot(x_eval, kde_bw2(x_eval), color='red', lw=2, linestyle='--', label='Density (BW Factor = 2)')

plt.title('Histogram of Assets with Density Overlays')
plt.xlabel('Assets (in millions)')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

```

## 2. Advanced Distribution Visualization: Boxenplots

To visualize the distribution of assets by fund type, specifically focusing on tail behavior, we used boxenplots.

### 2.1 Standard Scale

```{python}
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.boxenplot(x='Type', y='Assets', data=df, palette='muted')

plt.title('Boxenplot of Assets by Fund Type')
plt.xlabel('Fund Type')
plt.ylabel('Assets (in millions)')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

### 2.2 Logarithmic Scale

Recognizing the skew in the data, we reconstructed the boxenplot on a logarithmic scale.

```{python}
plt.figure(figsize=(10, 6))
ax = sns.boxenplot(x='Type', y='Assets', data=df, palette='muted')
ax.set_yscale("log")

plt.title('Boxenplot of Assets by Fund Type (Logarithmic Scale)')
plt.xlabel('Fund Type')
plt.ylabel('Assets (in millions, Log Scale)')
plt.grid(axis='y', which='both', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

## 3. Performance Analysis: 2009 Returns

We then shifted focus to the returns in 2009.

### 3.1 Boxenplot of Returns by Type

```{python}
plt.figure(figsize=(10, 6))
sns.boxenplot(x='Type', y='Return 2009', data=df, palette='muted')

plt.title('Boxenplot of 2009 Returns by Fund Type')
plt.xlabel('Fund Type')
plt.ylabel('Return in 2009 (%)')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

### 3.2 Violin Plot by Risk and Type

We introduced Risk into the analysis, visualizing returns with split violin plots.

```{python}
# Define categorical order for Risk
risk_order = ['Below average', 'Average', 'Above average']
# Ensure Risk column is categorical with order
if 'Risk' in df.columns:
    unique_risks = df['Risk'].unique()
    # Filter risk_order to only include present categories
    present_risks = [r for r in risk_order if r in unique_risks]
    # Add any missing risks to the end if necessary, or just use present_risks
    # This logic handles potential data mismatch
    df['Risk'] = pd.Categorical(df['Risk'], categories=risk_order, ordered=True)

plt.figure(figsize=(12, 7))
sns.violinplot(data=df, x='Risk', y='Return 2009', hue='Type', split=True, inner="quart")

plt.title('2009 Returns by Risk Level and Fund Type')
plt.xlabel('Risk Level')
plt.ylabel('Return 2009 (%)')
plt.legend(title='Fund Type')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

## 4. Horizontal Raincloud Plots

We refined the visualization into "Raincloud" plots to show density, raw data, and summary statistics simultaneously, oriented horizontally.

### 4.1 Bandwidth = 0.5 (Smoother)

```{python}
import numpy as np
from scipy.stats import gaussian_kde

types = sorted(df['Type'].unique())
colors = sns.color_palette("Set2", len(types))

fig, ax = plt.subplots(figsize=(12, 8))
type_offset = 0.4

for i, risk in enumerate(risk_order):
    for j, fund_type in enumerate(types):
        mask = (df['Risk'] == risk) & (df['Type'] == fund_type)
        if not mask.any(): continue
        data = df[mask]['Return 2009'].dropna()
        if len(data) < 2:
            continue
            
        # KDE with bandwidth 0.5
        kde = gaussian_kde(data, bw_method=0.5)
        x_range = np.linspace(df['Return 2009'].min() - 2, df['Return 2009'].max() + 2, 500)
        y_kde = (kde(x_range) / kde(x_range).max()) * 0.35
        baseline = i - (j * type_offset)
        
        # Plot Cloud
        ax.fill_between(x_range, baseline, baseline + y_kde, color=colors[j], alpha=0.5, label=fund_type if i == 0 else "")
        ax.plot(x_range, baseline + y_kde, color=colors[j], lw=1.5, alpha=0.8)
        # Plot Rain
        jitter = np.random.uniform(-0.12, -0.05, size=len(data))
        ax.scatter(data, baseline + jitter, color=colors[j], s=12, alpha=0.4, edgecolors='none')
        # Plot Box
        ax.boxplot(data, positions=[baseline - 0.22], vert=False, widths=0.1, patch_artist=True, showfliers=False, medianprops=dict(color='black', lw=1.5))

ax.set_yticks([i - (type_offset/2) for i in range(len(risk_order))])
ax.set_yticklabels(risk_order)
ax.set_xlabel('Return 2009 (%)')
ax.set_title('Horizontal Raincloud Plot: 2009 Returns (BW=0.5)')
ax.legend(title="Fund Type", loc='upper right')
plt.tight_layout()
plt.show()

```

### 4.2 Bandwidth = 0.25 (More Sensitive)

```{python}
fig, ax = plt.subplots(figsize=(12, 8))

for i, risk in enumerate(risk_order):
    for j, fund_type in enumerate(types):
        mask = (df['Risk'] == risk) & (df['Type'] == fund_type)
        if not mask.any(): continue
        data = df[mask]['Return 2009'].dropna()
        if len(data) < 2:
            continue
            
        # KDE with bandwidth 0.25
        kde = gaussian_kde(data, bw_method=0.25)
        x_range = np.linspace(df['Return 2009'].min() - 2, df['Return 2009'].max() + 2, 500)
        y_kde = (kde(x_range) / kde(x_range).max()) * 0.35
        baseline = i - (j * type_offset)
        
        ax.fill_between(x_range, baseline, baseline + y_kde, color=colors[j], alpha=0.5, label=fund_type if i == 0 else "")
        ax.plot(x_range, baseline + y_kde, color=colors[j], lw=1.5, alpha=0.8)
        jitter = np.random.uniform(-0.12, -0.05, size=len(data))
        ax.scatter(data, baseline + jitter, color=colors[j], s=12, alpha=0.4, edgecolors='none')
        ax.boxplot(data, positions=[baseline - 0.22], vert=False, widths=0.1, patch_artist=True, showfliers=False, medianprops=dict(color='black', lw=1.5))

ax.set_yticks([i - (type_offset/2) for i in range(len(risk_order))])
ax.set_yticklabels(risk_order)
ax.set_xlabel('Return 2009 (%)')
ax.set_title('Horizontal Raincloud Plot: 2009 Returns (BW=0.25)')
ax.legend(title="Fund Type", loc='upper right')
plt.tight_layout()
plt.show()

```

## 5. Scatterplot Analysis

We concluded by looking at relationships between variables.

### 5.1 Returns vs. Assets

```{python}
plt.figure(figsize=(12, 7))
sns.scatterplot(data=df, x='Assets', y='Return 2009', hue='Type', alpha=0.7)

plt.title('Scatterplot of 2009 Returns by Assets')
plt.xlabel('Assets (in millions)')
plt.ylabel('Return 2009 (%)')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='Fund Type')
plt.tight_layout()
plt.show()

```

### 5.2 Returns vs. Expense Ratio (Custom Symbols)

Here we used custom markers to denote Fees (Checkmark vs X) and color for Risk.

```{python}
# Define custom markers: Check for 'Yes', X for 'No'
markers = {"Yes": r'$\checkmark$', "No": "X"}

plt.figure(figsize=(12, 8))
sns.scatterplot(
    data=df,
    x='Expense Ratio',
    y='Return 2009',
    hue='Risk',
    style='Fees',
    markers=markers,
    s=150,
    alpha=0.8
)

plt.title('2009 Returns vs. Expense Ratio (Risk Color-coded, Fees by Symbol)')
plt.xlabel('Expense Ratio (%)')
plt.ylabel('Return 2009 (%)')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', title="Risk / Fees")
plt.tight_layout()
plt.show()

```

### 5.3 Interactive Plotly Scatterplot

Finally, here is the code to generate an interactive version of the previous plot using Plotly.

```{python}
import plotly.express as px

fig = px.scatter(
    df, 
    x='Expense Ratio', 
    y='Return 2009', 
    color='Risk', 
    symbol='Fees',
    symbol_map={'Yes': 'star', 'No': 'x'},
    category_orders={'Risk': risk_order},
    title='Interactive: 2009 Returns vs. Expense Ratio',
    labels={'Expense Ratio': 'Expense Ratio (%)', 'Return 2009': 'Return 2009 (%)'},
    hover_data=['Fund Number', 'Type', 'Assets'],
    template='plotly_white'
)
fig.show()

```

# Bond Funds Analysis: Complete Conversation Log

This document contains the complete analytical workflow generated during our session, formatted for use in Quarto.

## 1. Initial Exploration: Asset Distribution

We began by examining the distribution of assets across the funds using a histogram with density overlays.

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

# Load the dataset
df = pd.read_csv('./BondFunds.csv')
assets = df['Assets'].dropna()

# Define bin parameters
bin_size = 100
bins = np.arange(0, assets.max() + bin_size, bin_size)

# Create the plot
plt.figure(figsize=(12, 7))

# 1. Histogram
plt.hist(assets, bins=bins, density=True, color='skyblue', edgecolor='black', alpha=0.5, label='Histogram (Bins=100m)')

# Generate points for the KDE lines
x_eval = np.linspace(0, assets.max(), 1000)

# 2. Density with Default Bandwidth
kde_default = gaussian_kde(assets)
plt.plot(x_eval, kde_default(x_eval), color='blue', lw=2, label='Density (Default BW)')

# 3. Density with Bandwidth = 2
kde_bw2 = gaussian_kde(assets, bw_method=2.0)
plt.plot(x_eval, kde_bw2(x_eval), color='red', lw=2, linestyle='--', label='Density (BW Factor = 2)')

plt.title('Histogram of Assets with Density Overlays')
plt.xlabel('Assets (in millions)')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

```

## 2. Advanced Distribution Visualization: Boxenplots

To visualize the distribution of assets by fund type, specifically focusing on tail behavior, we used boxenplots.

### 2.1 Standard Scale

```{python}
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.boxenplot(x='Type', y='Assets', data=df, palette='muted')

plt.title('Boxenplot of Assets by Fund Type')
plt.xlabel('Fund Type')
plt.ylabel('Assets (in millions)')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

### 2.2 Logarithmic Scale

Recognizing the skew in the data, we reconstructed the boxenplot on a logarithmic scale.

```{python}
plt.figure(figsize=(10, 6))
ax = sns.boxenplot(x='Type', y='Assets', data=df, palette='muted')
ax.set_yscale("log")

plt.title('Boxenplot of Assets by Fund Type (Logarithmic Scale)')
plt.xlabel('Fund Type')
plt.ylabel('Assets (in millions, Log Scale)')
plt.grid(axis='y', which='both', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

## 3. Performance Analysis: 2009 Returns

We then shifted focus to the returns in 2009.

### 3.1 Boxenplot of Returns by Type

```{python}
plt.figure(figsize=(10, 6))
sns.boxenplot(x='Type', y='Return 2009', data=df, palette='muted')

plt.title('Boxenplot of 2009 Returns by Fund Type')
plt.xlabel('Fund Type')
plt.ylabel('Return in 2009 (%)')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

### 3.2 Violin Plot by Risk and Type

We introduced Risk into the analysis, visualizing returns with split violin plots.

```{python}
# Define categorical order for Risk
risk_order = ['Below average', 'Average', 'Above average']
# Ensure Risk column is categorical with order
if 'Risk' in df.columns:
    unique_risks = df['Risk'].unique()
    # Filter risk_order to only include present categories
    present_risks = [r for r in risk_order if r in unique_risks]
    # Add any missing risks to the end if necessary, or just use present_risks
    # This logic handles potential data mismatch
    df['Risk'] = pd.Categorical(df['Risk'], categories=risk_order, ordered=True)

plt.figure(figsize=(12, 7))
sns.violinplot(data=df, x='Risk', y='Return 2009', hue='Type', split=True, inner="quart")

plt.title('2009 Returns by Risk Level and Fund Type')
plt.xlabel('Risk Level')
plt.ylabel('Return 2009 (%)')
plt.legend(title='Fund Type')
plt.grid(axis='y', linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

```

## 4. Horizontal Raincloud Plots

We refined the visualization into "Raincloud" plots to show density, raw data, and summary statistics simultaneously, oriented horizontally.

### 4.1 Bandwidth = 0.5 (Smoother)

```{python}
import numpy as np
from scipy.stats import gaussian_kde

types = sorted(df['Type'].unique())
colors = sns.color_palette("Set2", len(types))

fig, ax = plt.subplots(figsize=(12, 8))
type_offset = 0.4

for i, risk in enumerate(risk_order):
    for j, fund_type in enumerate(types):
        mask = (df['Risk'] == risk) & (df['Type'] == fund_type)
        if not mask.any(): continue
        data = df[mask]['Return 2009'].dropna()
        if len(data) < 2:
            continue
            
        # KDE with bandwidth 0.5
        kde = gaussian_kde(data, bw_method=0.5)
        x_range = np.linspace(df['Return 2009'].min() - 2, df['Return 2009'].max() + 2, 500)
        y_kde = (kde(x_range) / kde(x_range).max()) * 0.35
        baseline = i - (j * type_offset)
        
        # Plot Cloud
        ax.fill_between(x_range, baseline, baseline + y_kde, color=colors[j], alpha=0.5, label=fund_type if i == 0 else "")
        ax.plot(x_range, baseline + y_kde, color=colors[j], lw=1.5, alpha=0.8)
        # Plot Rain
        jitter = np.random.uniform(-0.12, -0.05, size=len(data))
        ax.scatter(data, baseline + jitter, color=colors[j], s=12, alpha=0.4, edgecolors='none')
        # Plot Box
        ax.boxplot(data, positions=[baseline - 0.22], vert=False, widths=0.1, patch_artist=True, showfliers=False, medianprops=dict(color='black', lw=1.5))

ax.set_yticks([i - (type_offset/2) for i in range(len(risk_order))])
ax.set_yticklabels(risk_order)
ax.set_xlabel('Return 2009 (%)')
ax.set_title('Horizontal Raincloud Plot: 2009 Returns (BW=0.5)')
ax.legend(title="Fund Type", loc='upper right')
plt.tight_layout()
plt.show()

```

### 4.2 Bandwidth = 0.25 (More Sensitive)

```{python}
fig, ax = plt.subplots(figsize=(12, 8))

for i, risk in enumerate(risk_order):
    for j, fund_type in enumerate(types):
        mask = (df['Risk'] == risk) & (df['Type'] == fund_type)
        if not mask.any(): continue
        data = df[mask]['Return 2009'].dropna()
        if len(data) < 2:
            continue
            
        # KDE with bandwidth 0.25
        kde = gaussian_kde(data, bw_method=0.25)
        x_range = np.linspace(df['Return 2009'].min() - 2, df['Return 2009'].max() + 2, 500)
        y_kde = (kde(x_range) / kde(x_range).max()) * 0.35
        baseline = i - (j * type_offset)
        
        ax.fill_between(x_range, baseline, baseline + y_kde, color=colors[j], alpha=0.5, label=fund_type if i == 0 else "")
        ax.plot(x_range, baseline + y_kde, color=colors[j], lw=1.5, alpha=0.8)
        jitter = np.random.uniform(-0.12, -0.05, size=len(data))
        ax.scatter(data, baseline + jitter, color=colors[j], s=12, alpha=0.4, edgecolors='none')
        ax.boxplot(data, positions=[baseline - 0.22], vert=False, widths=0.1, patch_artist=True, showfliers=False, medianprops=dict(color='black', lw=1.5))

ax.set_yticks([i - (type_offset/2) for i in range(len(risk_order))])
ax.set_yticklabels(risk_order)
ax.set_xlabel('Return 2009 (%)')
ax.set_title('Horizontal Raincloud Plot: 2009 Returns (BW=0.25)')
ax.legend(title="Fund Type", loc='upper right')
plt.tight_layout()
plt.show()

```

## 5. Scatterplot Analysis

We concluded by looking at relationships between variables.

### 5.1 Returns vs. Assets

```{python}
plt.figure(figsize=(12, 7))
sns.scatterplot(data=df, x='Assets', y='Return 2009', hue='Type', alpha=0.7)

plt.title('Scatterplot of 2009 Returns by Assets')
plt.xlabel('Assets (in millions)')
plt.ylabel('Return 2009 (%)')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='Fund Type')
plt.tight_layout()
plt.show()

```

### 5.2 Returns vs. Expense Ratio (Custom Symbols)

Here we used custom markers to denote Fees (Checkmark vs X) and color for Risk.

```{python}
# Define custom markers: Check for 'Yes', X for 'No'
markers = {"Yes": r'$\checkmark$', "No": "X"}

plt.figure(figsize=(12, 8))
sns.scatterplot(
    data=df,
    x='Expense Ratio',
    y='Return 2009',
    hue='Risk',
    style='Fees',
    markers=markers,
    s=150,
    alpha=0.8
)

plt.title('2009 Returns vs. Expense Ratio (Risk Color-coded, Fees by Symbol)')
plt.xlabel('Expense Ratio (%)')
plt.ylabel('Return 2009 (%)')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', title="Risk / Fees")
plt.tight_layout()
plt.show()

```

### 5.3 Interactive Plotly Scatterplot

Finally, here is the code to generate an interactive version of the previous plot using Plotly.

```{python}
import plotly.express as px

fig = px.scatter(
    df, 
    x='Expense Ratio', 
    y='Return 2009', 
    color='Risk', 
    symbol='Fees',
    symbol_map={'Yes': 'star', 'No': 'x'},
    category_orders={'Risk': risk_order},
    title='Interactive: 2009 Returns vs. Expense Ratio',
    labels={'Expense Ratio': 'Expense Ratio (%)', 'Return 2009': 'Return 2009 (%)'},
    hover_data=['Fund Number', 'Type', 'Assets'],
    template='plotly_white'
)
fig.show()

```

```

```